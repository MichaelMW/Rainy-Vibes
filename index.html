<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minimal Matrix Rain</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="matrix"></canvas>
  <script>
    // Parameterized configuration for easy adjustment
    const CONFIG = {
      matrixRgb: '0,255,65',                  // RGB for matrix green
      headColor: 'rgba(180,255,180,0.7)',
      backgroundAlpha: 0.75,
      fontSize: 14,
      baseTrailLength: 12,
      maxTrailLength: 36,
      minSpeed: 0.8,
      maxSpeed: 3.5,
      sparseness: 0.75,
      resetProbability: 0.975,
      // Time dilation effect parameters
      timeDilation: {
        active: true,               // Toggle the effect on/off
        radius: 150,                // Radius of influence in pixels
        strength: 0.85,             // How much to slow down (0-1, lower = slower)
        falloff: 2,                 // Exponential falloff rate (higher = sharper edge)
        minSpeedFactor: 0.15        // Minimum speed factor at cursor center
      }
    };

    // Matrix rain characters (katakana, A-Z, 0-9)
    const MATRIX_CHARS = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズヅブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');

    // Get the canvas element safely and handle errors
    function getCanvasById(id) {
      const element = document.getElementById(id);
      if (!element) {
        throw new Error(`Canvas element with id '${id}' not found.`);
      }
      return element;
    }

    // Get a random Matrix character
    function getRandomChar() {
      return MATRIX_CHARS[Math.floor(Math.random() * MATRIX_CHARS.length)];
    }

    // Calculate trail length based on y position (gravity effect)
    function getTrailLength(y, screenHeight) {
      const ratio = Math.min(1, Math.max(0, y / screenHeight));
      return Math.round(CONFIG.baseTrailLength + (CONFIG.maxTrailLength - CONFIG.baseTrailLength) * Math.pow(ratio, 1.2));
    }

    // Calculate drop speed based on y position
    function getDropSpeed(y, screenHeight) {
      const ratio = Math.min(1, Math.max(0, y / screenHeight));
      return CONFIG.minSpeed + (CONFIG.maxSpeed - CONFIG.minSpeed) * Math.pow(ratio, 1.5);
    }

    // Get a random initial Y position for a stream
    function getRandomInitialY(screenHeight) {
      const minY = -CONFIG.baseTrailLength * CONFIG.fontSize;
      return minY + Math.random() * (screenHeight - minY);
    }

    // Create a single stream object
    function createStream(screenHeight) {
      return {
        y: getRandomInitialY(screenHeight),
        trail: Array.from({ length: CONFIG.baseTrailLength }, getRandomChar)
      };
    }

    // Create initial streams for each column
    function createStreams(numColumns, screenHeight) {
      return Array.from({ length: numColumns }, () => {
        if (Math.random() < CONFIG.sparseness) return null;
        return createStream(screenHeight);
      });
    }

    // Draw a single stream's trail
    function drawStreamTrail(ctx, stream, x, screenHeight) {
      const trailLength = getTrailLength(stream.y, screenHeight);
      // Extend or shrink trail to match calculated length
      while (stream.trail.length < trailLength) stream.trail.unshift(getRandomChar());
      while (stream.trail.length > trailLength) stream.trail.pop();
      // Draw trail from tail to head for proper fading
      for (let t = trailLength - 1; t >= 0; t--) {
        const y = stream.y - t * CONFIG.fontSize;
        if (y < 0 || y > screenHeight) continue;
        const alpha = 0.12 + 0.38 * (1 - t / trailLength);
        ctx.fillStyle = t === 0
          ? CONFIG.headColor
          : `rgba(${CONFIG.matrixRgb},${alpha})`;
        ctx.fillText(stream.trail[t], x, y);
      }
    }

    // Advance a stream's state
    function advanceStream(stream, screenHeight, x, mouse) {
      const trailLength = getTrailLength(stream.y, screenHeight);
      const baseSpeed = getDropSpeed(stream.y, screenHeight);
      
      // Apply time dilation based on distance to cursor
      const dilationFactor = getTimeDilationFactor(x, stream.y, mouse);
      const speed = baseSpeed * dilationFactor;
      
      stream.trail.pop();
      stream.trail.unshift(getRandomChar());
      stream.y += speed * CONFIG.fontSize;
      
      // Reset stream to top with some randomness
      if (stream.y - trailLength * CONFIG.fontSize > screenHeight && Math.random() > CONFIG.resetProbability) {
        stream.y = getRandomInitialY(screenHeight);
      }
    }

    // Calculate time dilation factor based on distance to mouse cursor
    function getTimeDilationFactor(x, y, mouse) {
      // If effect is disabled or mouse is not on canvas, no dilation
      if (!CONFIG.timeDilation.active || !mouse.active) {
        return 1;
      }
      
      // Calculate distance from stream to mouse cursor
      const dx = x - mouse.x;
      const dy = y - mouse.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Apply smooth falloff based on distance
      if (distance >= CONFIG.timeDilation.radius) {
        return 1; // No effect beyond radius
      }
      
      // Calculate dilation factor - approaches minSpeedFactor at center
      const normalizedDistance = distance / CONFIG.timeDilation.radius;
      const dilationStrength = Math.pow(normalizedDistance, CONFIG.timeDilation.falloff);
      
      // Blend between minimum speed factor and normal speed
      return CONFIG.timeDilation.minSpeedFactor + 
             (1 - CONFIG.timeDilation.minSpeedFactor) * dilationStrength;
    }

    // Draw a single frame of Matrix rain
    function drawMatrixRain(ctx, canvas, streams, columns, mouse) {
      ctx.fillStyle = `rgba(0, 0, 0, ${CONFIG.backgroundAlpha})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = CONFIG.fontSize + 'px monospace';
      ctx.textBaseline = 'top';
      for (let i = 0; i < columns; i++) {
        const stream = streams[i];
        if (!stream) continue;
        const x = i * CONFIG.fontSize;
        drawStreamTrail(ctx, stream, x, canvas.height);
        advanceStream(stream, canvas.height, x, mouse);
      }
      
      // Draw time dilation bubble indicator (subtle visual feedback)
      if (CONFIG.timeDilation.active && mouse.active) {
        const gradient = ctx.createRadialGradient(
          mouse.x, mouse.y, 0,
          mouse.x, mouse.y, CONFIG.timeDilation.radius
        );
        gradient.addColorStop(0, 'rgba(255,255,255,0.1)');
        gradient.addColorStop(0.7, 'rgba(255,255,255,0.03)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, CONFIG.timeDilation.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Set canvas size and reinitialize streams
    function setCanvasAndStreams(canvas) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const columns = Math.floor(canvas.width / CONFIG.fontSize);
      const streams = createStreams(columns, canvas.height);
      return { columns, streams };
    }

    // Main execution
    (function main() {
      const canvas = getCanvasById('matrix');
      const ctx = canvas.getContext('2d');
      let { columns, streams } = setCanvasAndStreams(canvas);
      
      // Track mouse position
      const mouse = {
        x: -1000,
        y: -1000,
        active: false
      };
      
      // Mouse event handlers
      function updateMousePosition(e) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
        mouse.active = true;
      }
      
      function resetMousePosition() {
        mouse.active = false;
        mouse.x = -1000;
        mouse.y = -1000;
      }
      
      // Add mouse event listeners
      canvas.addEventListener('mousemove', updateMousePosition);
      canvas.addEventListener('mouseout', resetMousePosition);
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        updateMousePosition(e.touches[0]);
      });
      canvas.addEventListener('touchend', resetMousePosition);

      // Redraw and resize handler
      function onResize() {
        const result = setCanvasAndStreams(canvas);
        columns = result.columns;
        streams = result.streams;
      }
      window.addEventListener('resize', onResize);

      // Animation loop
      function animate() {
        drawMatrixRain(ctx, canvas, streams, columns, mouse);
        requestAnimationFrame(animate);
      }
      animate();
    })();
  </script>
</body>
</html>
