<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Creative Matrix Rain Effect</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="matrix"></canvas>
  <script>
    const canvas = document.getElementById('matrix');
    const ctx = canvas.getContext('2d');

    // Animated background gradient
    let gradAngle = 0;
    function drawBackground() {
      gradAngle += 0.002;
      const grad = ctx.createLinearGradient(
        canvas.width/2 + Math.cos(gradAngle)*canvas.width/2, 0,
        canvas.width/2 - Math.cos(gradAngle)*canvas.width/2, canvas.height
      );
      grad.addColorStop(0, `hsl(${(gradAngle*60)%360}, 60%, 10%)`);
      grad.addColorStop(1, `hsl(${(gradAngle*60+120)%360}, 60%, 10%)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Set canvas size
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Characters to use (including some creative symbols)
    const chars = 'ã‚¢ã‚¡ã‚«ã‚µã‚¿ãƒŠãƒãƒãƒ¤ãƒ£ãƒ©ãƒ¯ã‚¬ã‚¶ãƒ€ãƒãƒ‘ã‚¤ã‚£ã‚­ã‚·ãƒãƒ‹ãƒ’ãƒŸãƒªãƒ°ã‚®ã‚¸ãƒ‚ãƒ“ãƒ”ã‚¦ã‚¥ã‚¯ã‚¹ãƒ„ãƒŒãƒ•ãƒ ãƒ¦ãƒ¥ãƒ«ã‚°ã‚ºãƒ…ãƒ–ãƒ—ã‚¨ã‚§ã‚±ã‚»ãƒ†ãƒãƒ˜ãƒ¡ãƒ¬ãƒ±ã‚²ã‚¼ãƒ‡ãƒ™ãƒšã‚ªã‚©ã‚³ã‚½ãƒˆãƒãƒ›ãƒ¢ãƒ¨ãƒ§ãƒ­ãƒ²ã‚´ã‚¾ãƒ‰ãƒœãƒãƒ´ãƒƒãƒ³ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()[]{}<>?~'.split('');

    // Creative twist: Each column has a random color and speed, and sometimes "glitches" with emoji or ASCII art
    const emojis = ['ğŸ’€','ğŸ‘¾','ğŸ¤–','ğŸ¦¾','ğŸ§¬','âš¡','ğŸ”¥','ğŸŒŸ','âœ¨','ğŸ›¸','ğŸš€','ğŸ¦„','ğŸ²','ğŸ®','ğŸµ','ğŸ¶','ğŸ¤','ğŸ§','ğŸ”®','ğŸ§ ','ğŸ•¹ï¸'];
    const asciiArt = ['<3', ':-)', 'Â¯\\_(ãƒ„)_/Â¯', 'âˆ', 'Ï€', 'Î©', 'Î£', 'Î»', 'Ïˆ', 'Î”'];

    const fontSize = 20;
    let columns = Math.floor(window.innerWidth / fontSize);
    let drops = [];
    let colors = [];
    let speeds = [];
    let directions = [];
    let portalColumns = [];
    let rainbowMode = false;
    let rainbowModeTimer = 0;
    let glitchTimer = 0;
    let explosionColumns = [];

    function initColumns() {
      columns = Math.floor(window.innerWidth / fontSize);
      drops = [];
      colors = [];
      speeds = [];
      directions = [];
      portalColumns = [];
      explosionColumns = [];
      for (let i = 0; i < columns; i++) {
        drops[i] = Math.random() * -50;
        colors[i] = `hsl(${Math.random() * 360}, 80%, 60%)`;
        speeds[i] = 1 + Math.random() * 2;
        directions[i] = 1;
        if (Math.random() < 0.05) portalColumns[i] = Math.floor(Math.random()*columns);
        else portalColumns[i] = null;
        explosionColumns[i] = 0;
      }
    }
    initColumns();
    window.addEventListener('resize', () => {
      resize();
      initColumns();
    });

    function triggerRainbowMode() {
      rainbowMode = true;
      rainbowModeTimer = 120 + Math.floor(Math.random()*120); // 2-4 seconds
    }
    function triggerGlitch() {
      glitchTimer = 30 + Math.floor(Math.random()*30); // 0.5-1s
    }
    function triggerExplosion(col) {
      explosionColumns[col] = 20 + Math.floor(Math.random()*20);
    }

    function draw() {
      drawBackground();
      if (rainbowMode) {
        rainbowModeTimer--;
        if (rainbowModeTimer <= 0) rainbowMode = false;
      }
      if (glitchTimer > 0) {
        glitchTimer--;
        ctx.save();
        ctx.setTransform(1, 0.1*Math.sin(glitchTimer*2), 0.1*Math.cos(glitchTimer*2), 1, Math.random()*10-5, Math.random()*10-5);
      }
      ctx.font = fontSize + "px monospace";
      for (let i = 0; i < columns; i++) {
        // Rainbow mode color
        let colColor = rainbowMode ? `hsl(${(Date.now()/10+i*20)%360}, 100%, 60%)` : colors[i];
        // Occasionally reverse direction
        if (Math.random() < 0.0005) directions[i] *= -1;
        // Occasionally trigger portal
        let portal = portalColumns[i];
        let char;
        if (explosionColumns[i] > 0) {
          char = emojis[Math.floor(Math.random()*emojis.length)];
          colColor = `hsl(${Math.random()*360},100%,70%)`;
          explosionColumns[i]--;
        } else if (Math.random() < 0.003) {
          triggerExplosion(i);
          char = emojis[Math.floor(Math.random()*emojis.length)];
        } else if (Math.random() < 0.005) {
          char = emojis[Math.floor(Math.random() * emojis.length)];
        } else if (Math.random() < 0.01) {
          char = asciiArt[Math.floor(Math.random() * asciiArt.length)];
        } else {
          char = chars[Math.floor(Math.random() * chars.length)];
        }
        ctx.fillStyle = colColor;
        let y = drops[i] * fontSize;
        ctx.fillText(char, i * fontSize, y);
        // Portal: teleport char to another column
        if (portal !== null && Math.random() < 0.01) {
          drops[portal] = drops[i];
        }
        // Rain logic
        drops[i] += speeds[i] * directions[i];
        if (directions[i] === 1 && drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
          colors[i] = `hsl(${Math.random() * 360}, 80%, 60%)`;
          speeds[i] = 1 + Math.random() * 2;
        }
        if (directions[i] === -1 && drops[i] < 0) {
          drops[i] = Math.floor(canvas.height/fontSize);
          colors[i] = `hsl(${Math.random() * 360}, 80%, 60%)`;
          speeds[i] = 1 + Math.random() * 2;
        }
      }
      if (glitchTimer > 0) ctx.restore();
      // Rarely trigger rainbow mode or glitch
      if (!rainbowMode && Math.random() < 0.0005) triggerRainbowMode();
      if (glitchTimer === 0 && Math.random() < 0.0007) triggerGlitch();
      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
