<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minimal Matrix Rain</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="matrix"></canvas>
  <script>
    // Parameterized configuration for easy adjustment
    const CONFIG = {
      matrixRgb: '0,255,65',                  // RGB for matrix green
      headColor: 'rgba(180,255,180,0.7)',
      backgroundAlpha: 0.75,
      fontSize: 14,
      baseTrailLength: 12,
      maxTrailLength: 36,
      minSpeed: 0.8,
      maxSpeed: 3.5,
      sparseness: 0.75,
      resetProbability: 0.975
    };

    // Matrix rain characters (katakana, A-Z, 0-9)
    const MATRIX_CHARS = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズヅブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');

    // Get the canvas element safely and handle errors
    function getCanvasById(id) {
      const element = document.getElementById(id);
      if (!element) {
        throw new Error(`Canvas element with id '${id}' not found.`);
      }
      return element;
    }

    // Get a random Matrix character
    function getRandomChar() {
      return MATRIX_CHARS[Math.floor(Math.random() * MATRIX_CHARS.length)];
    }

    // Calculate trail length based on y position (gravity effect)
    function getTrailLength(y, screenHeight) {
      const ratio = Math.min(1, Math.max(0, y / screenHeight));
      return Math.round(CONFIG.baseTrailLength + (CONFIG.maxTrailLength - CONFIG.baseTrailLength) * Math.pow(ratio, 1.2));
    }

    // Calculate drop speed based on y position
    function getDropSpeed(y, screenHeight) {
      const ratio = Math.min(1, Math.max(0, y / screenHeight));
      return CONFIG.minSpeed + (CONFIG.maxSpeed - CONFIG.minSpeed) * Math.pow(ratio, 1.5);
    }

    // Get a random initial Y position for a stream
    function getRandomInitialY(screenHeight) {
      const minY = -CONFIG.baseTrailLength * CONFIG.fontSize;
      return minY + Math.random() * (screenHeight - minY);
    }

    // Create a single stream object
    function createStream(screenHeight) {
      return {
        y: getRandomInitialY(screenHeight),
        trail: Array.from({ length: CONFIG.baseTrailLength }, getRandomChar)
      };
    }

    // Create initial streams for each column
    function createStreams(numColumns, screenHeight) {
      return Array.from({ length: numColumns }, () => {
        if (Math.random() < CONFIG.sparseness) return null;
        return createStream(screenHeight);
      });
    }

    // Draw a single stream's trail
    function drawStreamTrail(ctx, stream, x, screenHeight) {
      const trailLength = getTrailLength(stream.y, screenHeight);
      // Extend or shrink trail to match calculated length
      while (stream.trail.length < trailLength) stream.trail.unshift(getRandomChar());
      while (stream.trail.length > trailLength) stream.trail.pop();
      // Draw trail from tail to head for proper fading
      for (let t = trailLength - 1; t >= 0; t--) {
        const y = stream.y - t * CONFIG.fontSize;
        if (y < 0 || y > screenHeight) continue;
        const alpha = 0.12 + 0.38 * (1 - t / trailLength);
        ctx.fillStyle = t === 0
          ? CONFIG.headColor
          : `rgba(${CONFIG.matrixRgb},${alpha})`;
        ctx.fillText(stream.trail[t], x, y);
      }
    }

    // Advance a stream's state
    function advanceStream(stream, screenHeight) {
      const trailLength = getTrailLength(stream.y, screenHeight);
      const speed = getDropSpeed(stream.y, screenHeight);
      stream.trail.pop();
      stream.trail.unshift(getRandomChar());
      stream.y += speed * CONFIG.fontSize;
      // Reset stream to top with some randomness
      if (stream.y - trailLength * CONFIG.fontSize > screenHeight && Math.random() > CONFIG.resetProbability) {
        stream.y = getRandomInitialY(screenHeight);
      }
    }

    // Draw a single frame of Matrix rain
    function drawMatrixRain(ctx, canvas, streams, columns) {
      ctx.fillStyle = `rgba(0, 0, 0, ${CONFIG.backgroundAlpha})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = CONFIG.fontSize + 'px monospace';
      ctx.textBaseline = 'top';
      for (let i = 0; i < columns; i++) {
        const stream = streams[i];
        if (!stream) continue;
        const x = i * CONFIG.fontSize;
        drawStreamTrail(ctx, stream, x, canvas.height);
        advanceStream(stream, canvas.height);
      }
    }

    // Set canvas size and reinitialize streams
    function setCanvasAndStreams(canvas) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const columns = Math.floor(canvas.width / CONFIG.fontSize);
      const streams = createStreams(columns, canvas.height);
      return { columns, streams };
    }

    // Main execution
    (function main() {
      const canvas = getCanvasById('matrix');
      const ctx = canvas.getContext('2d');
      let { columns, streams } = setCanvasAndStreams(canvas);

      // Redraw and resize handler
      function onResize() {
        const result = setCanvasAndStreams(canvas);
        columns = result.columns;
        streams = result.streams;
      }
      window.addEventListener('resize', onResize);

      // Animation loop
      function animate() {
        drawMatrixRain(ctx, canvas, streams, columns);
        requestAnimationFrame(animate);
      }
      animate();
    })();
  </script>
</body>
</html>
